import tensorflow as tf
import numpy as np
import math

import numpy as np
import tensorflow as tf
import math
from tensorflow.python.ops import array_ops
from tensorflow.python.ops import functional_ops
import functools

# To download the network:
import urllib

# To handle files:
import os.path
import sys
import tarfile

tfgan = tf.contrib.gan
session = tf.InteractiveSession()        

BATCH_SIZE0 = 100
#This is BATCH_SIZE0, which is DIFFERENT from 'BATCH_SIZE', declared a few lines below
inception_images=tf.placeholder(tf.float32,[BATCH_SIZE0,3,None,None])
def GetInceptionLogits(num_splits=1, images=inception_images):
    images=tf.transpose(images,[0,2,3,1])
    size = 299
    images = tf.image.resize_bilinear(images, [size, size])
    generated_images_list = array_ops.split(
        images, num_or_size_splits=num_splits)
    logits = functional_ops.map_fn(
        fn=functools.partial(tfgan.eval.run_inception, output_tensor='logits:0'),
        elems=array_ops.stack(generated_images_list),
        parallel_iterations=1,
        back_prop=False,
        swap_memory=True,
        name='RunClassifier')
    logits = array_ops.concat(array_ops.unstack(logits), 0)
    return logits


# logits should be created with the inception_logits function
def RunInceptionNetwork(inps, logits, batch_size):
    preds = []
    n_batches = len(inps)//batch_size
    for i in range(n_batches):
        print('Batch ', i, '...')
        inp = inps[i * batch_size:(i + 1) * batch_size]
        pred = logits.eval({inception_images:inp})[:,:1000]
        preds.append(pred)
    preds = np.concatenate(preds, 0)
    preds=np.exp(preds)/np.sum(np.exp(preds),1,keepdims=True)
    return preds
    

#ppp = GetPool3Layer('./InceptionNetwork')
#print(ppp)


#import time
#from tensorflow.python.ops import array_ops
#from tensorflow.python.ops import functional_ops

# This is the default version of inception score:
#      - The score is calculated only based on images generated by the generative model
#      - Observations stated in "A Note on the Inception Score" are taken into account
#      - The code is based on: 


# BATCH_SIZE: the number of images loaded at once
BATCH_SIZE=100

# Input: ndimarray, with a shape [N, 3, HEIGHT, WIDTH], N, HEIGHT an WIDTH are arbitrary

# Step0: Assertions:


# Step1: Convert inputs to a form that is accepted by the inception network.
#def convert_input(imgs):
#    inps = []
#    for img in images:
#        img = img.astype(np.float32)
#        inps.append(np.expand_dims(img, 0))
#    return imps

# Step2: Calculate the inception scores for each split from the predictions

def calc_notexp_inception_score(preds, splits):
    scores = []
    for i in range(splits):
        part = preds[(i * preds.shape[0]//splits) : ((i+1)*preds.shape[0] //splits), :]
        # Writing the log(Q/P) part of KL-divergence as logQ - logP
        kl = part * (np.log(part) - np.log(np.expand_dims( np.mean(part, 0), 0)))
        kl = np.mean(np.sum(kl, 1))
        scores.append(kl)
    return scores

# Can be made faster by not calling calc_notexp_inception_score
def calc_inception_score(preds, splits):
    return np.exp(calc_notexp_inception_score(preds, splits))

# Executing Step0, Step1, Step2, Step3:
# n_splits is set to 1 by default for reasons explained in "A Note on Inception Score"
def InceptionScore(images, n_splits = 1):
    assert(type(images) == np.ndarray)
    assert(len(images.shape) == 4)
    assert(images.shape[1]==3)
    assert(np.max(images[0])<=1)
    assert(np.min(images[0])>=-1)
    #inps = convert_input(images)
    print('Getting logits...')
    logits = GetInceptionLogits(n_splits)
    print('Running Inception Network...')
    preds = RunInceptionNetwork(images, logits, BATCH_SIZE)
    print('Calculating Scores...')
    scores = calc_inception_score(preds, n_splits)
    return np.mean(scores), np.std(scores)

#-------------------------------------------------------------------------------
# Mode Score:
#-------------------------------------------------------------------------------

"""
This is the version of Mode Score described in "An empirical study
on evaluation metrics of generative adversarial networks" (which might
differ slightly from other versions).
"""
# <- magyarul

# Kérdés: ez így valid?
def KLDiv(Q, P):
    KL = Q*(np.log(Q) - np.log(P) )
    return np.mean(np.sum(KL, 1))

def mode_score_second_part(gen_preds, real_preds, n_splits):
    scores = []
    for i in range(n_splits):
        partG = gen_preds[(i * gen_preds.shape[0] //n_splits) : 
                          ((i+1)*gen_preds.shape[0] //n_splits), :]
        partR = real_preds[(i * real_preds.shape[0] //n_splits) 
                           : ((i+1)*real_preds.shape[0] //n_splits), :]
        Q = np.expand_dims( np.mean(partG, 0), 0)
        P = np.expand_dims( np.mean(partR, 0), 0)
        KL = Q*( np.log(Q) - np.log(P) )
        KL = np.mean(np.sum(KL, 1))
        scores.append(KL)
    return scores

def calc_mode_score(gen_preds, real_preds, splits):
    scores = []
    for i in range(splits):
        part = preds[(i * preds.shape[0]//splits) : ((i+1)*preds.shape[0] //splits), :]
        # Writing the log(Q/P) part of KL-divergence as logQ - logP
        kl = part * (np.log(part) - np.log(np.expand_dims( np.mean(part, 0), 0)))
        kl = np.mean(np.sum(kl, 1))
        scores.append(kl)


# MEGÍRNI AZ ÚJ MÓDON !!
def ModeScore(gen_images, real_images, n_splits):
    # Alap hibakezelés:
    assert(type(gen_images) == np.ndarray)
    assert(len(gen_images.shape) == 4)
    assert(gen_images.shape[1]==3)
    assert(np.max(gen_images[0])<=1)
    assert(np.min(gen_images[0])>=-1)
    assert(type(real_images) == np.ndarray)
    assert(len(real_images.shape) == 4)
    assert(real_images.shape[1]==3)
    assert(np.max(real_images[0])<=1)
    assert(np.min(real_images[0])>=-1)
    assert(len(gen_images) == len(real_images))
    assert(gen_images[0].shape[0] == real_images[0].shape[0])
    print('Getting logits...')
    logits = GetInceptionLogits(n_splits)
    # Get the predictions of the inception network:
    print('Running Inception Network on generated data...')
    # Note: BATCH_SIZE defined above
    gen_preds = RunInceptionNetwork(gen_images, logits, BATCH_SIZE)
    print('Running Inception Network on real data...')
    real_preds = RunInceptionNetwork(real_images, logits, BATCH_SIZE)
    print('Calculating Scores...')
    # Ez itt helyes, mert: várható értékek összege egyenlő az összegek várható értékével
    # ?: numerikus problémák?
    inc_scores = calc_notexp_inception_score(gen_preds, n_splits)
    sec_scores = mode_score_second_part(gen_preds, real_preds, n_splits)
    inc_scores = np.concatenate(inc_scores)
    sec_scores = np.concatenate(sec_scores)
    inc_scores = inc_scores - sec_scores
    inc_scores = inc_scores.tolist()
    inc_scores = np.exp(inc_scores)
    return np.mean(inc_scores), np.std(inc_scores)

